
DelayCurvesTheoretical <- function(basic, advanced, mat){

  # DelayCurvesTheoretical: Takes as input the mat structure generated by
  # DelayCurvesRecur and DelayStageOne (the dynamic programming stage II and
  # stage I, respectively). Generates a new figure with stopping boundaries if
  # their asymptotically approximate values are known (e.g. from Chick & Gans,
  # or from Chick & Frazier).
  # Takes as input the basic and advanced data structures which were used to
  # generate the computations stored in mat. Also output is an updated
  # version of the mat structure with the upper theoretical bound as well.
  #
  # NB: This is actually a modified version of C&F and C&G in sense that,
  # when fixedP <- FALSE then the extra number of patients treated is brought
  # into the equation for the variance.
  #
  # 2014 May 17: Created by Steve
  #
  # Converted to R code by Michael Dymock 2024

  matout <- mat
  c <- basic$c                # cost per sample
  delta <- -log(basic$theta)  # continuous time discount rate per sample
  sampvar <- basic$sigma^2*(basic$PPatients + (1 - advanced$fixedP)*(basic$TMax - (mat$tvec - basic$tau)))^2
  posttvec <- mat$tvec - basic$tau  # posterior at time tvec has tvec - tau samples observed

  symmetryline <- basic$ICost/basic$PPatients  # line at which one is indifferent between technologies

  if(delta == 0){  # first check to see if results of Chick & Frazier hold (case of no discounting)
    subtitle <- "C&F"
    # NB: Formally, C&F only looked at the offline case. But we give the
    # curve for the offline learning even if the case study is for online learning
    if(c > 0){  # no discounting, but yes there are positive sampling costs
      gamma <- (c^2/sampvar)^(1/3)  # compute parameters for rescaling
      betainv <- (c*sampvar)^(1/3)
      svec <- 1/(gamma*posttvec)
      stopbound <- betainv*CFApproxBoundW(svec) + basic$ICost  # stopping boundary at population level
      stopbound2 <- -betainv*CFApproxBoundW(svec) + basic$ICost
    } else {
      posttvec <- c()
      stopbound <- c()
      stopbound2 <- c()
    }

    if(basic$online){  # implemented theory only for offline with no discounting
      subtitle <- "C&F offline, but online=1"
      if(advanced$fixedP){
        subtitle <- "C&F offline fixedP (but online=1)"
        # if fixed contract at end, then set theoretical upper to that for our computation: should be 'infinity' (or mumax)
        stopbound <- basic$PPatients*mat$bndupper
      } else {
        subtitle <- "C&F offline fixedP (but online=1, fixedP=0)"
      }
      # postvec <- c()
      # stopbound <- c()
    }
  } else {  # case of discounting, recall result of brezzi and lai : same bound for online and offline with discounting
    subtitle <- "C&G"
    alpha <- sqrt(delta/sampvar)
    betainv <- sqrt(delta*sampvar)
    # alpha <- sqrt(delta)/basic$sigma
    # betainv <- sqrt(delta)*basic$sigma
    gamma <- delta

    if(c > 0){
      svec <- 1/(gamma*posttvec)
      stopbound <- betainv*CGApproxBoundW(svec) + basic$ICost

      # Use Theorem 4 of C&G to approximate time rescaling
      # kappainv <- delta^(3/2)*basic$sigma/(c/basic$PPatients)
      kappainv <- delta^(3/2)*sqrt(basic$PPatients)*basic$sigma/c
      binvm <- 1/(gamma*CGApproxBoundWInv(kappainv))
      posttvecscaled <- posttvec  # allocate memory
      posttvecscaled[binvm > posttvec] <- posttvec[binvm > posttvec]*binvm/(binvm - posttvec[binvm > posttvec])
      posttvecscaled[binvm <= posttvec] <- 5*max(posttvec)  # pick some really big value here, essentially infinity
      svec <- 1/(gamma*posttvecscaled)
      stopbound <- betainv*CGApproxBoundW(svec) + basic$ICost
      # stopbound[binvm <= posttvec] <- basic$ICost   # put as fixed cost - essentially have perfect info (s=0 here; or tvec infty)
    } else {
      svec <- 1/(gamma*posttvec)
      stopbound <- betainv*CGApproxBoundW(svec) + basic$ICost
    }
    stopbound2 <- numeric(0)  # no quick approx formula for lower bound in this case (need access to full PDE solution: have not yet hooked it up)
  }

  # Update matout with theoretical bounds
  matout$theoryupperbnd <- stopbound/basic$PPatients
  matout$theorylowerbnd <- stopbound2/basic$PPatients

  return(matout)
}